---
layout: post
title: Spine.js 简介
categories: notes
---

官方文档: [http://spinejs.com/docs/index](http://spinejs.com/docs/index){:target='_blank'} <br>
官方API: [http://spinejs.com/api/index](http://spinejs.com/api/index){:target='_blank'}

## 1) Classes and Modules(类和模块)

作为类,Spine使用的是CoffeeScript默认的类实现.

{% highlight coffeescript linenos %}
class User
  # 类方法
  @find: (id) ->
    (@records or={})[id]
    
  # constructor函数
  # 这里不是JavaScript中通常意义上的构造函数,
  constructor: (attributes = {}) ->
    @attributes = attributes
    
  # 实例方法
  save: ->
  destroy: ->
{% endhighlight %}
  
使用`new`关键字来实例化类,由此我们可以知道类本身其实就是构造函数.

{% highlight coffeescript linenos %}
user = new User(name: 'Leo')
user.save()

user = User.find(user.id)
user.destroy()
{% endhighlight %}

在CoffeeScript中,使用`extends`的方式来继承类.

{% highlight coffeescript linenos %}
class Users extends Spine.Controller
  # 假如你从另外一个类中实现继承,然后又要重写`constructor`函数,请确保调用`super`方法.
  # 特别是在Spine的模型和控制器中的使用当中.
  constructor: ->
    super
{% endhighlight %}

### 1.1) Context

JavaScript程序通常牵扯到很多执行环境改变的情况,特别是关系到事件回调函数.
不如说是通过手动进行代理回调,才让他们在正确的作用域下执行.而CoffeeScript
的函数语法提供了一个有用的选择,一个胖箭头函数`=>`.

{% highlight coffeescript linenos %}
class TaskApp extends Spine.Controller
  constructor: ->
    super
    Task.bind('create', @addOne)
    Task.bind('refresh', @addAll)
    Task.fetch()
    
  addOne: (task) =>
    view = new Tasks(item: task)
    @append(view.render())
  
  addAll: =>
    Task.each(@addOne)
{% endhighlight %}
    
### 1.2) Modules

Spine扩展CoffeeScript中类对模块的支持(Module),通过`Spine.Module`我们可以得到`@extend()`和`@include()`方法,
从而可以非常方便的添加类和实例的两种不同属性.要使用模块仅仅让类从`Spine.Module`中继承.

{% highlight coffeescript linenos %}
class MyTask extends Spine.Module
  @extend ClassModule
  @include InstanceModule
{% endhighlight %}  

Spine内部的类是从`Spine.Module`中继承的,所以他们都拥有`@extend()`和`@include()`的支持.

{% highlight coffeescript linenos %}
class User extends Spine.Model
  @configure 'User'
  @extend Spine.Model.Ajax
{% endhighlight %}  

模块就是像这样简单的一组属性.

{% highlight coffeescript linenos %}
OrmModule = {
  find: (id) -> # /* ... */
}
{% endhighlight %}

模块也同时包含回调函数,`@extend()`和`@include()`.

{% highlight coffeescript linenos %}
OrmModule =
  find: (id) -> # /* ... */
  extended: ->
    console.log('module extended: ', @)
{% endhighlight %}

## 2) Model(模型)

客户端的应用不同于通常的服务器端应用,他们通常没有请求和响应模型,你也不能访问服务器端的变量.作为客户端应用,数据是从远程提取出来然后暂时存储在客户端.这样有个优势,就是数据访问是实时的,这让用户可以很少,甚至不必为了从远程加载数据而耗费等待的时间.当初始化的页面加载完毕之后,远程的数据被暂时存储在本地的类结构中(叫做模型),模型是Spine的核心,而且对你的应用是至关重要的,不仅仅是因为模型可以在本地存储应用的数据,并且他们同时也是把数据和逻辑关联的所在.  模型应该从你的应用当中解藕然后完全独立出来,模型数据可以依靠`HTML5 Local Storage`或Ajax而持续保留.在Spine中,模型是通过继承`Spine.Model`类的方式创建的.  

{% highlight coffeescript linenos %}
Class Contact extends Spine.Model
  # 在模型内部,你应该在所有表达式之前调用`configure()`方法,由此引导各种变量和事件.
  # 在`configure`方法中传递该模型的名字以及该模型拥有的任何其他属性(字段).
  @configure 'Contact', 'name', 'address'
{% endhighlight %}

模型就像其他的CoffeeScript类,所以你同样可以添加类或实例方法.

{% highlight coffeescript linenos %}
class Contact extends Spine.Model
  @configure 'Contact', 'name', 'address', 'phone'
  
  @filter: (query) ->
    @select (c) ->
      c.name.indexOf(query) isnt -1
      
  userInfo: -> [@name, @address, @phone].join(',')
{% endhighlight %}


模型(Model)是Spine的模块(module),所以你可以像这样扩展(extending)和导入(including)属性.

{% highlight coffeescript linenos %}
class User extends Spine.Model
  @configure 'User', 'username', 'email'
  
  @extend MyModule
{% endhighlight %}
  
模型同样也可以简单的实现子类.
{% highlight coffeescript linenos %}
class Member extends User
  @configure 'Member'
{% endhighlight %}

### 2.1) Saving/Retrieving Records

一旦一个实例被创建,可以通过调用`save()`方法来将它保存在内存中.

{% highlight coffeescript linenos %}
class User extends Spine.Model
  @configure 'User', 'username', 'email'

leo = new User(username: 'John Leo', email: 'johnleo@gmail.com')
leo.save()

{% endhighlight %}

当一条记录被保存,Spine将自动为它创建一个简单的客户ID(假如它之前没有)

{% highlight coffeescript linenos %}
leo = new User(username: 'John Leo', email: 'johnleo@gmail.com')
leo.save()

assertEqual(leo.id, 'c-1')
{% endhighlight %}


我们可以通过`find()`方法来查找记录,而假如`find()`查找失败,默认会返回一个`null`,通过返回值以确保你知道检查结果.另外,你也可以调用`exists()`方法来检查一条记录是否存在.

{% highlight coffeescript linenos %}
indenticalUser = User.find(leo.id)
assert(elo.eql(indenticalUser))

assert(User.exists(leo.id))
{% endhighlight %}

一旦你更改了任何记录的属性,你可以重新调用`save()`方法在内存中更新它.

{% highlight coffeescript linenos %}
user = new User(name: 'Yuwen', email: 'yuwen.s512@gmail.com')
user.save()
user.name = 'Lorenzo'
user.save()
{% endhighlight %}

你也可以使用`first()`和`last()`方法分别取得第一个和最后一个记录.

{% highlight coffeescript linenos %}
firstUser = User.first()
recentMessages = Message.last(10)
{% endhighlight %}

如果要提取所有的记录,使用`all()`.

{% highlight coffeescript linenos %}
posts = Post.all()
console.log(post.title) for post in posts
{% endhighlight %}

通过`slice()`方法来提取某个区间的数据集合

{% highlight coffeescript linenos %}
a = Post.slice(3)         # => 3,4,5,6,...
b = Post.slice(10, 100)   # => 9,10,...,99
{% endhighlight %}

你可以使用`each()`方法传入一个函数然后在每一条记录上都执行一遍.

{% highlight coffeescript linenos %}
User.each(user) -> console.log(user.name)
{% endhighlight %}

或者使用`select()`方法来选择记录的一个子集.(有点像jQuery中的$.grep,但也不同)

{% highlight coffeescript linenos %}
User.select(user) -> user.name
{% endhighlight %}

### 2.2) Validation

模型中的验证非常简单,只要单单的用你自定义的内容来重写`validate()`函数.

{% highlight coffeescript linenos %}
class Contact extends Spine.Model
  # ...
  validate: ->
    unless @name
      'Name is required!'
{% endhighlight %}      

假如`validate()`返回任何内容,验证将失败,然后这个模型上的一个`error`事件将会触发.你可以通过监听该模型从而将它捕获,然后通知用户.另外,`save()`,`create()`,`updateAttributes()`都会在验证失败的时候返回false

{% highlight coffeescript linenos %}
Contact.bind 'error', (rec, msg) ->
  alert('Contact failed to save - ' + msg)
{% endhighlight %}

### 2.3) Serialization

Spine的模型包含对JSON序列化的特殊支持,序列化一条记录,调用`JSON.stringify()`方法然后把记录传递进去,或者序列化每一条记录就把模型传递进去.

{% highlight coffeescript linenos %}
JSON.stringify(User.first())
JSON.stringify(User)
{% endhighlight %}

另外,你还可以提取实例的属性(attributes)然后调用`attributes()`方法来实现你自己的序列化.

{% highlight coffeescript linenos %}
contact = new Contact(name: 'Yuwen Song')
assertEqual(contact.attributes(), {name: 'Yuwen Song'})

Contact.include
  toXML: ->
    serializeToXML(@attributes())
{% endhighlight %}
    
*假如需要支持那些不支持原生JSON的老式浏览器(比如:IE7等),你需要添加json2.js以获得遗留的支持.*

### 2.4) Persistence

把记录存储在内存中对于快速查找而言是非常有用的,通常会要求通过一种或其他方式让他们继续存在. Spine包含一些预置的存储模块,就像`ajax`和`HTML5 Local Storage`. 假如你想从`Ajax`或`HTML5 Local Storage`中拉取数据然后让他们栖居在模型的集合中,就用`fetch()`方法.

{% highlight coffeescript linenos %}
Contact.fetch()
{% endhighlight %}


### 2.5) Events

你已经注意到模型已经有一些关联的事件,比如`error`和`ajaxError`,但`create/update/destroy`操作的事件回调呢? Spine也已经包含了. 你可以直接这样绑定这些事件:

{% highlight coffeescript linenos %}
# save        => 保存记录,(包括create和update)
# update      => 记录被更新了.
# create      => 记录被创建了.
# destroy     => 记录被删除了.
# change      => 包括以上所有事件,created/updated/destroyed
# refresh     => 当记录验证通过或者添加了,使用refresh方法.
# error       => 验证失败
Contact.bind 'create', (contact) ->
  console.log(contact + ' is created.')
{% endhighlight %}

作为模型级别的回调函数,任何相关联的记录总是被传递到这个回调函数中.而其他的是直接绑定在这个记录(某个实例)上的事件.

{% highlight coffeescript linenos %}
contact = Contact.last()
contact.bind 'save', ->
  # Contact被更新
  updateInterface()
{% endhighlight %}

这个回调函数的执行环境将是绑定这个事件监听的实例. 在模型绑定实例到视图中以确保视图和应用的数据保持同步时,你会发现模型事件是至关重要的.

假如你想删除事件,可以在模型中调用`unbind()`方法来解除特定的事件. 模型的实例同样拥有`unbind()`方法,但它只能解除关联在这个实例上的每一个事件监听.

### 2.6) Dynamic records

在Spine的模型中另外一个是动态记录,使用原型继承来保持更新.任何调用`find()`,`all()`,`first()`,`last()`等方法提取的记录, 以及模型事件回调返回的`clone`对象都属于动态记录. 这就是说,任何记录被更新,它的`clone`对象也会立刻被更新.

{% highlight coffeescript linenos %}
asset = Asset.create(name: 'whatshisname')
clone = Asset.find(asset.id)
asset.updateAttributes(name:'leo')
assertEqual(clone.name, 'leo')
{% endhighlight %}

*这里的意思是你不必再在实例上调用一些烦人的reload()函数了,你可以确定所有的实例都是始终和他们保存的版本保持同步.*

## 3) Controllers(控制器)

通常来说,控制器处理添加和反应DOM事件,渲染模板以及保持视图和模型的同步这些事务. 控制器同模型一样继承自Spine.Module类.所以它同样继承了`extend()`,`include()`等方法.你可以使用他们来向控制器中添加属性. 

{% highlight coffeescript linenos %}
class Users extends Spine.Controller
  constructor: ->
    super
    # 在实例化的时候调用

tasks = new Tasks
{% endhighlight %}

每一个控制器都有一个元素于它关联,而它就是你可以访问的这个控制器的*实例属性`el`*. 这个元素在创建控制器实例的时候自动被设置. 这个元素的类型可以通过指定特定的标签(tag)属性来更改,默认是`div`.
{% highlight coffeescript linenos %}
class TaskItem extends Spine.Controller
  tag: 'li'

# `taskItem.el`变成了一个<li></li>元素.
taskItem = new TaskItem

# 这个`el`属性也可以<在实例化的过程中手动传进去>设置
tasks = new Tasks(el: $('#tasks'))

# 事实上,任何在实例化过程中传递的东西都将会被设置为这个新实例的属性.
# 比如:你传递了一个于控制器关联的记录.
taskItem = new TaskItem(item: Task.first())
{% endhighlight %}

*在你的控制器的`constructor()`函数内,你通常会引用控制器内的某个函数来添加**模型和视图的事件监听**.*

### 3.1) Events

Spine通过events属性提供了一个快捷的方式来添加事件监听到DOM元素.

{% highlight coffeescript linenos %}
class Tasks extends Spine.Controller
  events:
    'click .task': 'justAClick'
  
  justAClick: (e) ->
    # 当`.task`元素被点击的时候调用
{% endhighlight %}

事件是一个类似这种格式的对象{'eventType selector', 'functionName'}. 所有的选择器都被控制器关联的元素`el`限定了作用域,假如没有提供一个选择器,这个事件将会被直接添加到`el`上. 否则它将会被委托到任何匹配到的子选择器上.(*这句翻译可能有误,请参考原文的意思:otherwise it'll be delegated to any children matching the selector*)

Spine会替你非常小心的注意回调的上下文环境,确保它保持到正确的控制器. 回调将被传递一个事件对象,然后你可以访问那个事件被真正触发(`event.target`)的原始元素.

{% highlight coffeescript linenos %}
class ToggleView extends Spine.Controller
  constructor: ->
    super
    @items = @$('.items')
    @items.click => @trigger('toggle')
    @bind 'toggle', @toggle

    toggle: ->
      # ...
{% endhighlight %}

### 3.2) Elements

当你第一次实例化一个控制器, 它通常会设置涉及各种元素的一堆实例变量. 举例来说:设置`items`变量在`Tasks`控制器中.
{% highlight coffeescript linenos %}
class Tasks extends Spine.Controller
  constructor: ->
    super
    @items = @$('.items')
{% endhighlight %}

由于这是一个如此普遍的情况,Spine提供了一个helper: `elements`属性. 它是这样的格式{'selector': 'variableName'}. 当控制器被实例化.Spine将通过(go through)`elements`, 设置合适的元素作为实例的属性.就像事件,所有的选择器都被控制器的当前元素`el`限定了作用域.

{% highlight coffeescript lonenos %}
class Tasks extends Spine.Controller
  elements:
    '.items': 'items'
  constructor: ->
    super
    @items.each -> #...
{% endhighlight %}


## 4) Events(事件)

事件是一种强大的方式在应用中解藕交互,他们不仅仅局限于DOM元素. Spine让你可以在任何类或实例上自定义事件,假如你熟悉jQuery或者Zepto的事件API,那么在Spine的事件实现中你会感觉到轻车熟路一样自在.事件在应用当中解藕和提炼抽象出组件是一种非常棒的方式.

### 4.1) Implementation

`Spine.Events`是Spine用来添加事件支持到类中的模块,仅在一个类中include/extend这个模块就可以使用它.

{% highlight coffeescript linenos %}
class Tasks extends Spine.Controller
  @extend(Spine.Events)
{% endhighlight %}

`Spine.Events`提供给你一些基础的函数,`bind()`, `trigger()` 和 `unbind()`.所有这三个方法都有一个和jQuery的事件处理非常类似的API,假如你熟悉他们.  `bind(name, callback)`接受一个*事件名*和一个*回调*. `trigger(name, [*data])`接受一个*事件名*和一个被传递给事件处理器的可选的*data*. `unbind(name, [callback])`接受一个*事件名*和一个可选的*回调*. 

{% highlight coffeescript linenos %}
Tasks.bind 'create', (foo, bar) -> alert(foo + bar)
Tasks.trigger 'create', 'some', 'data'
{% endhighlight %}

你可以绑定多重事件,仅仅用空格把他们分开.回调函数这个事件关联的上下文环境中被调用.

{% highlight coffeescript linenos %}
Tasks.bind('create update destroy', -> @trigger('change'))
{% endhighlight %}

这些方法允许一个对象去监听在另外一个对象上的事件. 而允许这个*监听对象*跟踪事件的轨迹*意味着他们可以在稍后同一时间全部被稳妥的移除*. 比如当你`release()`或者`destroy()`掉这个监听对象,这些事件将会自动的被解除绑定. 
尽管你也许不会在你自己的类中使用`Spine.Events`,但在你的Spine应用当中将在模型和控制器中使用他们.

它的进阶使用方法是这样的:


{% highlight coffeescript linenos %}
todoList = new TodoList()
todoList.listenTo currentTarget, 'work-done, completed', ->
  doSomething()

# 而不是:
currentTarget.bind 'work-done, completed', ->
  doSomething()
{% endhighlight %}

### 4.2) Global Events

你还可以在你的应用当中通过调用`Spine.bind()`和`Spine.trigger()`来绑定和触发全局事件
{% highlight coffeescript linenos %}
Spine.bind 'sidebar:show', =>
  @sidebar.active()

Spine.trigger 'sidebar:show'
{% endhighlight %}

然而,请牢记这并非是一种很好的方式,就像它在你的代码中耦合所展示的样子. 在使用他们之前请先询问自己是否可以使用路由或者可能使用本地的控制器事件代替呢?

## 5) Views & Templating(视图和模板)

在Spine的术语中,视图就是用来组合应用接口的简单HTML片段. Spine没有任何复杂的UI组件或规定如何构建你的视图. 这完全由你自己决定.

为了确保你的应用接口是完全异步和响应式的,你应该把视图的渲染全部放在客户端处理.这就是说代替服务器端的模板,
类似Ruby的ERB或者Python的字符串格式化.我们需要客户端的JavaScript模板.

这里有许多不错的选择,类似[Mustache](http://mustache.github.io/){:target='_blank'}和[Jade](http://jade-lang.com/){:target='_blank'}. 但我们在这里示范如何使用[eco](https://github.com/sstephenson/eco){:target='_blank'}. *除了Eco,Jade是另外一个Hem内建的模板的解决方案.*

### 5.1) Eco templates

JavaScript模板同服务器端模板非常相似.通过一些特定的标签于HTML结合在一起,然后在渲染的过程中那些标签将被执行和替换.
而关于Eco模板最棒的事就是他们本身就是用CoffeeScript写的.

{% highlight erb linenos %}
<% if @projects.length: %>
  <% for project in @projects: %>
    <a href="<%= project.url %>"><%= project.name %></a>
    <p><%= project.description %></p>
  <% end %>
<% else %>
  No projects.
<% end %>
{% endhighlight %}

你可以看到,这些语法是异常明显的,只需要给*需要执行的表达式*使用`<%` 标签, 而通过`<%=`标签来显示他们.<br>
完整的模板标签列表如下:<br>
*<small>由于这里翻译的不准确,所以在每一段下面贴出了原文,自己琢磨.</small>*

•`<% expression %>`
  : 计算一个CoffeeScript表达式,无需返回值. `<% if %>` <br>
  *<small>Evaluate a CoffeeScript expression without printing its return value.</small>*

•`<%= expression %>`
  : 计算一个CoffeeScript表达式,泄漏(escape)它的返回值,然后显示出来. 这里的意思应该是说计算这个表达式之后,会返回一个值(被表达式泄漏出来的),然后通过<%=标签展示出来.<br>
  *<small>Evaluate a CoffeeScript expression, escape its return value, and print it.</small>*

•`<%- expression %>`
  : 计算一个CoffeeScript表达式然后显示它的返回值,但无需泄漏(escape)出来.<br>
  *<small>Evaluate a CoffeeScript expression and print its return value without escaping it.</small>*

•`<%= @property %>`
  : 显示这个*在渲染的时候*传递过来的*上下文环境对象*的属性值<br>
  *<small>Print the escaped value of the property property from the context object passed to render.</small>*

•`<%= @helper() %>`
  : 调用*在渲染的时候*传递过来的上下文环境对象的helper方法,然后显示它泄漏出来的值.<br>
  *<small>Call the helper method helper from the context object passed to render, then print its escaped return value.</small>*

•`<% @helper -> %>...<% end %>`
  : 调用将一个函数作为第一个参数的helper方法,当被调用的时候,这个*参数函数*将捕获然后返回标签内的内容.<br>
  *<small>Call the helper method helper with a function as its first argument. When invoked, the function will capture and return the content ... inside the tag.</small>*

模板在当前环境下同上下文(context)当中被计算,就像一个模型的实例,CoffeeScript中的`@`符号就像`this`,指向当前环境的上下文.


### 5.2) Compiling templates

Eco让你在浏览器端动态的编译模板,或者使用Node预编译他们.当然我建议使用预编译,作为预处理是一次性的处理,那样可以节省一些处理的时间.

Hem事实上内建了预编译eco模板的支持,只需要简单的把视图文件以`.eco`作为扩展名就行. 他们同应用的其他部分一样被包装成函数然后可以在使用的时候调用他们.

{% highlight coffeescript linenos %}
# 在这里,我们仅仅是require了视图文件,然后立即调用它.
# 传递给它一个相应的上下文环境(在这里就是一个模型的记录)
render: ->
  @html require('app/views/contact')(@contact)

{% endhighlight %}

调用这个视图将返回一个字符串形式的渲染后的模板,那个被我们直截了当地传递给`@html()`函数,更新控制器的`@el`元素.<br>
*<small>Calling the view returns the rendered template as a string, which we're passing straight to the @html() function, updating the controller's @el element.</small>*

### 5.3) Data association

Eco模板整个被处理成字符串,所以我们不可能把一个对象关联到模板的HTML元素上.
比如:不可能通过Eco模板去呈现记录的列表,监听一个点击事件然后把点击事件关联到原始的记录上.
非常不幸,这些在web应用当中都是十分常见的情况.

所幸的是Hem通过`.jeco`后缀的模板拯救了这种情况,假如你把视图模板的扩展改为`.jeco`代替`.eco`. 
他们将会被包裹在一个jQuery选择器关联的*包含data的元素*.

{% highlight coffeescript linenos %}
# app/views/contacts.jeco
<div class="item"></div>

# app/controllers/contacts.coffee
class Contacts extends Spine.Controller
  events: 'click .item': 'clicked'

  render: ->
    items = Contact.all()
    @html = require('views/contacts')(items)
  clicked: (e) ->
    element = $(e.target)
    item = element.data('item')
    @log 'Contact #{item.name} was clicked.'
{% endhighlight %}

你可以看到在`clicked()`回调函数中,我们通过事件对象`e`找到该`element`所关联的元素,然后又找到记录(record)关联的这个元素`item`上. Spine为此提供了一个快捷方式,在`spine/lib/tmpl`:中

{% highlight coffeescript linenos %}
# app/controllers/contacts.coffee
require('spine/lib/tmpl')
class Contacts extends Spine.Controller
  clicked: (e) ->
    item = $(e.target).item()
    @log 'Contact #{item.name} was clicked'
{% endhighlight %}

`tmpl.coffee`组件提供了jQuery对象`$.fn.item()`函数, 它将返回于元素关联的`data`.  而`.jeco`模板同样有一些高级功能,你可以用数组来渲染,然后他们会自动的遍历.

### 5.4) Template helper

模板helper对于某些特殊的视图逻辑有极大的用处,无需在视图中编写大量的逻辑代码从而违反MVC原则.模板helper应该当作属性写在控制器里面, 然后当渲染的时候以*在模板里面传递控制器实例*的方式来调用.

举个例子: 当我们在一个货币应用的`Currencies`控制器中,我们需要用逗号分隔每三位数来格式化`@output`和`@input`数值. 这是一个使用模板helper的理想情况.

{% highlight coffeescript linenos %}
class Currencies extends Spine.Controller
  render: ->
    @output = @input and (@input * @rate()).toFixed(2) or 0
    @html require('views/currency')(@)

    helper:
      format:
        num.toString().replace(/\B(?=(?:\d{3})+(?!\d))/g, ",")
{% endhighlight %}

然后我们在模板中调用这个helper,传递给它合适的变量.

{% highlight erb linenos %}
<section class="input">
  <h1><%= @helper.format(@input) %></h1>
  <h1><%= @helper.format(@output) %></h1>
</section>
{% endhighlight %}

*如此简单明了!*


### 5.5) Binding

数据绑定在保证模型和视图的数据同步方面是一种非常强大的技术,这种情况是指用控制器绑定模型的事件,然后当事件被触发的时候重新渲染视图. 让我们来看一个简单的例子: 一个联系人列表. 将控制器绑定联系人模型的`refresh`和`change`事件,这两个事件在模型数据改变的时候会触发. 当`refresh`或`change`事件触发的时候,控制器会重新渲染视图.

{% highlight coffeescript linenos %}
class Contacts extends Spine.Controller
  constructor: ->
    Contact.bind('refresh change', @render)

  render: =>
    items = Contact.all()
    @html require('views/contacts')(items)
{% endhighlight %}

注意我们在`render()`函数上使用了`=>`. 这可以确保`render()`是在正确的ContactList上下文环境中被调用的.

## 6) Routing

Spine在基于URL的哈希段上提供了应用的路由,例如: `http://example.com/#/users`包含哈希片段`/users`. 哈希段可以是完全自己定义,它不会触发页面的重新加载以维持页面的状态. 你的应用也可以用Google的[Ajax Crawling](http://code.google.com/web/ajaxcrawling/index.html){:target='_blank'}特性的哈希段来定义路由.

本质上Spine使用的是`hashchange`事件来检测Urls哈希里面的改变. 这个事件只在最近才建立,所以它只对新的浏览器有效. 如果你要支持那些陈旧的浏览器,你可以使用完美的jQuery[hashchange](http://benalman.com/projects/jquery-hashchange-plugin/){:targte='_blank'}插件,它使用了一些聪明的技巧和iframe来模仿事件.

### 6.1) Adding routes

那么,如何使用API? 很简单,首先你需要引入`route.coffee`,它包含了`Spine.Route`模块.然后你就可以在你的控制器当中添加路由了. `Spine.Route`提供给你一个控制器内的`routes()`函数,你可以通过传递一个哈希路由和回调的方式来调用它.

{% highlight coffeescript linenos %}
class App extends Spine.Controller
  constructor: ->
    @routes
      '/users/:id': (params) ->
        console.log('/users/', params.id)
      '/users': ->
        console.log('users')
{% endhighlight %}

路由参数是这样的格式 `:name`, 然后作为`arguments`被传递给关联的回调中. 你也可以像这样通过一个星号来匹配任何东西.(*<small>You can also use globs to match anything via an asterisk, like so:</small>*)

{% highlight coffeescript linenos %}
@routes
  '/pages/*glob': (params) ->
    console.log('/pages', params.glob)
{% endhighlight %}

路由以一种*特性的反序*来添加,所以大部分特殊的路由应该首先添加,
然后普通的`catch alls`应该稍后添加.值得一提的是,特别是你在控制器当中的`constructor()`函数中添加路由的时候, 不应该添加多个路由.上面的例子是正确的,`App`控制器每次最多只能被实例化一次.

另外一种选择是直接跳过控制器然后直接用`Spine.Route.add()`来添加路由, 要么传递一个哈希或者单个路由.

{% highlight coffeescript linenos %}
Spine.Route.add /\/groups(\/)?/, -> console.log("groups")
{% endhighlight %}

你可以看到,路由也可以使用正则,在匹配方面给你完全的控制权.

### 6.2) Initial Setup

当页面初始化加载的时候,即使URL里面包含哈希段`hashchange`事件都不会被调用,它只会在之后的改变中调用.这指的是当我们的应用启动以后,我们需要手动的告诉Spine我们想执行路由和检查URL的哈希,这可以通过调用`Spine.Route.setup()`来完成.

{% highlight coffeescript linenos %}
Spine.Route.setup()

# 或者
callback = (path, options)->
  alert '#{path}, and #{options}'
Spine.Route.setup({redirect: callback})
{% endhighlight %}

### 6.3) Navigate

最后,Spine提供了控制器的一个`navigate()`函数,在这个函数内可以传递一个片段去改变路由的哈希. 你还可以传递给`navigate()`函数多个参数,它会自动用`/`斜线来组合成一个片段.

{% highlight coffeescript linenos %}
class Users extends Spine.Controller
  constructor: ->
    # Navigate to #/users/:id
    @navigate('/users', @item.id)

new Users(item: User.first())
{% endhighlight %}

在使用`navigate()`的时候要确保URL的片段是于它相关的控制器保持同步的. 默认情况下,调用`navigate()`将会触发路由的回调,假如你不想触发路由,传递一个`false`布尔值作为最后的参数给`navigate()`.

{% highlight coffeescript linenos %}
# 传递`false`之后不会触发
Spine.Route.navigate('/users', false)
{% endhighlight %}

### 6.4) HTML5 History

Spine也提供给你使用HTML5 History API的选择,它有一个好处是可以在不重新加载页面或者使用哈希段的方式来改变URL,这指可以提供一种让你的用户所习惯的清晰的URL格式.

要使用HTML5 History API, 在`Spine.Route.setup()`中传入`{history:true}`来代替哈希段.

{% highlight coffeescript linenos %}
Spine.Route.setup(history: ture)
{% endhighlight %}

HTML5 History只有在提供了选项和API可访问的情况下才有效,否则Spine的路由会恢复到使用哈希段的形式.

无论如何,当在使用HTML5 History API的时候有些事情你需要注意.
首先,每一个传递给`navigate()`的URL都必须要有相对应的实际HTML代表(*<small>representation,请阅读以下内容再考虑这里的意思</small>*).
尽管浏览器在这一点上不会请求新的URL,但假如页面重新加载,随后它会重新请求.
换句话说,你无法像使用哈希段那样随心所欲的定义URL,每一个传递给API的URL都必须实际存在.
这种实现的一种方法是要服务器端的支持.

但浏览器请求了一个URL(期待一个HTML响应),你首先要确定所请求的URL在服务器端是存在和有效的,然后你可以启动(server up)主应用去读取URL,调用合适的路由.举个例子: 让我们假设你的用户访问http://example.com/users/1. 在服务器端,你要检查URL`/users/1`是否有效,然后检查User列表里面是有有一个ID为1的记录存在. 然后你才可以运行(server up)你的JavScript应用.

### 6.5) Shimming

有些时候在无需页面的URL或哈希段改变的情况下使用路由非常方便,这在满屏的移动端应用或PhoneGap应用当中是一种特殊的常见场景,他们的页面地址永远不会显示. 为了迎合这种情况,`Route.setup()`接受一个`shim`选项,举个例子: 

{% highlight coffeescript linenos %}
Spine.Route.setup(shim: true)
{% endhighlight %}
